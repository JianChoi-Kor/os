
운영체제의 기초 (CPU 스케줄링, 메모리 관리, 디스크 스케줄링)



운영체제란?


운영체제는 컴퓨터 하드웨어 바로 위에 설치되어 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층으로, 모든 컴퓨터 시스템의 필수적인 부분입니다.

운영체제는 다른 소프트웨어들과는 다르게 하드웨어를 직접 다루는 복잡한 부분을 운영체제가 대행함으로써 컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공하는 역할을 하며, 컴퓨터 시스템의 자원을 효율적으로 관리하는 역할도 수행합니다.
(CPU, 메모리, I/O 장치 등이 최대한의 성능을 내도록)



위 내용에 대해 조금 더 자세하게 알아보면, 현재 컴퓨터 시스템은 한 대의 컴퓨터에서 여러 프로그램을 동시에 실행시킬 수 있는 환경을 지원하는데요.
(노래를 듣고, 프로그래밍을 하면서 구글링도 할 수 있는)
하지만 이때 각각의 프로그램에서는 다른 프로그램을 신경쓰지 않고 해당 프로그램 혼자 컴퓨터에서 실행되고 있다고 생각하며 작업이 수행되며, 이러한 작업을 가능하게 하는 것이 바로 운영체제 때문입니다.

***
하지만 운영체제의 가장 중요한 목적은 바로 컴퓨터 시스템의 자원을 효율적으로 관리하는 것인데요.
(여기서 자원이란 CPU, 메모리, I/O 장치 등을 이야기합니다.)

한 대의 컴퓨터에서 여러 프로그램이 동작할 때 운영체제가 자원에 대한 쉐어링을 해주게 되는 것인데,
실행 중인 프로그램들에게 짧은 시간씩 CPU를 번갈아서 할당하며, CPU의 처리 속도가 매우 빠르기 때문에(0.1초 이내) 프로그램의 입장에서는 CPU가 번갈아 할당되는지 모르고 해당 프로그램 혼자 실행되는 것으로 생각하는 것입니다.

메모리 역시 유한한 용량을 가지고 있는데요. 때문에 여러 프로그램을 동시에 실행시키면 프로그램이 메모리에 올라가고 언젠가는 메모리가 다 소진되게 됩니다.
때문에 어떤 프로그램에 메모리 용량을 얼마나 할당할지에 대한 문제도 운영체제의 역할입니다.
(메모리는 CPU의 작업 공간으로도 생각할 수 있으며, CPU에서 프로그램이 실행되기 위해서는 반드시 메모리에 올라가야 합니다.)




컴퓨터 시스템의 구조



컴퓨터 시스템의 구조를 살펴보면 컴퓨터 내부(CPU, 메모리)와 입출력(I/O) 디바이스로 나눠서 살펴볼 수 있습니다.
(입출력 디바이스에서 프린트나 모니터는 출력 디바이스, 키보드나 마우스는 입력 디바이스이며, 디스크의 경우 입력과 출력을 모두 할 수 있는 디바이스 입니다.)

컴퓨터가 부팅 된다는 것은 운영체제가 메모리에 올라가서 실행되는 것이며, 운영체제는 컴퓨터가 꺼지기 전까지 항상 실행되는 프로그램입니다.
(운영체제에서 가장 핵심적인 부분은 커널이며, 커널은 메모리에 상주하게 됩니다.)

내부적인 동작 과정을 살펴보면 CPU의 작업 공간을 메모리라고 부르고, CPU는 매 클럭(clock)마다 메모리 어딘가에 있는 기계어를 읽어서 연산을 수행하는데요.
CPU의 작업 공간은 메모리이기 때문에 CPU가 디스크 등의 I/O 장치에 직접 접근할 수는 없습니다.
때문에 각 I/O 장치에는 I/O Controller라고 하는 입출력 디바이스를 전담하는 CPU가 별도로 존재하게 됩니다.

CPU는 짧은 시간 간격으로 여러 프로그램에 번갈아 할당되기 때문에 운영체제의 가장 중요한 역할 중에 하나가 바로 어떤 프로그램에게 CPU 사용권을 줄지, 얼마동안 줄 것인지를 결정하는 CPU 스케줄링입니다.



CPU 스케줄링


여러 프로그램들이 CPU를 사용하기 위해 CPU 큐에서 대기하는 상황
이때 어떤 프로그램에게 우선적으로 CPU를 할당할지 결정하는 것이 운영체제의 중요한 역할 중 하나입니다.
(모든 프로그램은 입력 -> 연산 -> 출력의 과정, 즉 CPU를 쓰고 I/O를 쓰는 과정이 반복됩니다.)


FCFS(First-Come First-Served)
먼저 들어온 순서대로 작업을 처리하는 방법으로 효율적이지는 않습니다.
(P1이 먼저 왔지만 CPU를 오래 점유하기 때문에 P2, P3가 기다리는 시간이 길어집니다.)


SJF(Shortest-Job-First)
FCFS의 단점을 해소하기 위한 방법입니다.
CPU의 사용 시간이 가장 짧은 프로세스를 가장 먼저 스케줄링합니다.
minimun average waiting time을 보장하지만 Starvation(기아 현상)이 발생할 수 있다는 문제점이 생깁니다.
(P1이 스케줄링을 기다리고 있는 상황에서 P1보다 사용 시간이 짧은 프로세스들이 계속 들어온다면 P1은 계속 작업을 하지 못하는 형평성의 문제가 발생할 수 있습니다.)


RR(Round Robin)
라운드 로빈은 현재 CPU 스케줄링에서 가장 많이 사용되는 방식입니다.
각 프로세스는 동일한 크기의 CPU 할당 시간을 가지며, 할당 시간이 끝나면 인터럽트가 발생하여 프로세스는 CPU를 빼앗기고 다시 CPU 큐의 마지막에서 다시 할당을 기다리게 됩니다.
대기 시간은 프로세스의 CPU 사용 시간에 비례하며, 해당 방법은 효율성과 형평성이 모두 고려되는 방법입니다.
(해당 방법은 CPU를 빼앗는 방법이 필요하며, CPU를 빼앗는 것은 운영체제 혼자 할 수 없기 때문에 하드웨어 적인 지원을 통해 인터럽트를 발생시켜야 합니다.)



메모리 관리



각각의 실행 파일을 실행 시키면 해당 파일이 메모리에 올라가서 프로세스가 됩니다.
정확하게는 메모리에 바로 올라가는 것이 아니고 가상 메모리를 거쳐 메모리에 올라가게 되는데요.
실제 물리적인 메모리에는 가상 메모리에서 당장 필요한 부분만 올라가게 되고, 메모리가 다 찼을 때는 디스크(스왑영역)으로 이동되게 됩니다.
(스왑 영역은 메모리의 연장 공간으로 생각할 수 있습니다.)

***
디스크(파일 시스템), 디스크(스왑영역)은 하나의 디스크지만 용도가 다릅니다.




메모리 공간이 꽉 찼을 때는 기존 메모리 공간을 차지하고 있던 페이지를 제거해야 하는데요.
기존 페이지를 제거하는 여러 방법 중에서 아래 두 가지 LRU, LFU 방식에 대해서 살펴보겠습니다.
(미래를 모르는 상황에서 미래에 다시 사용될 가능성이 낮은 페이지를 제거하는 것이 효율적인 메모리 관리)

LRU(Least Recently Used)
가장 오래 전에 사용된 페이지를 삭제하는 방식으로 메모리 뿐만 아니라 다른 곳에서도 사용되는 방식입니다.
오래 전에 사용되고 더 이상 사용되지 않은 페이지는 다시 사용될 가능성이 낮다는 예측을 기반으로 합니다.
(최근에 사용된 페이지가 재사용 가능성이 높다는 예측)

LFU(Least Frequently Used)
사용된 횟수가 가장 적은 페이지를 삭제하는 방식입니다.
과거에 많이 사용된 페이지는 다시 사용될 가능성이 높다는 예측을 기반으로 합니다.



디스크 스케줄링




디스크에 파일을 읽거나 저장하는 요청이 들어오면 해당 프로세스들도 마찬가지로 디스크 큐에 저장됩니다.

디스크에 접근 시간 중에 가장 많은 시간을 차지하는 부분이 바로 디스크 헤드의 이동 시간인데요.
따라서 디스크 요청을 효율적으로 관리한다는 것은 디스크 헤드의 이동을 줄이는 것으로도 볼 수 있습니다.

디스크 접근 시간(Access time)의 구성을 살펴보면 아래와 같습니다.

- 탐색 시간(Seek time)
: 헤드를 해당 트랙(실린더)으로 움직이는데 걸리는 시간

- 회전 지연(Rotational latency)
: 헤드가 원하는 섹션에 도달하기까지 걸리는 시간

- 전송 시간(Transfer time)
: 실제 데이터의 전송 시간

=> seek time을 최소화하는 것이 목표




디스크 스케줄링 FCFS(First-Come First-Served)
헤드의 이동이 길어지기 때문에 비효율적인 방법으로 해당 방법은 사용되지 않습니다.


디스크 스케줄링 SSTF(Shortest Seek Time First)
현재 헤드의 위치에서 가장 가까운 위치의 요청을 먼저 처리하는 방식입니다.
CPU 스케줄링의 SJF처럼 Starvation 문제가 발생할 수 있다는 단점이 있습니다.


디스크 스케줄링 SCAN
디스크 스케줄링에서 가장 많이 사용되는 방법입니다.
헤드가 디스크의 한쪽 끝에서 다른 쪽 끝으로 이동하며 가는 길목에 있는 모든 요청을 처리합니다.
다른 한쪽 끝에 도달하면 역방향으로 이동하며 오는 길목에 있는 모든 요청을 처리하며 다시 반대쪽 끝으로 이동합니다.
(엘리베이터 스케줄링이 SCAN 방식과 같은 원리로 동작합니다.)


























